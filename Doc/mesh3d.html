<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>mesh3d API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mesh3d</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mesh3d.calculate_principal_moments"><code class="name flex">
<span>def <span class="ident">calculate_principal_moments</span></span>(<span>inertia_matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_principal_moments(inertia_matrix):
    &#34;&#34;&#34;
    Calcula os momentos principais de inércia e os eixos principais a partir de uma matriz de inércia.
    
    Esta função decompõe a matriz de inércia em seus valores próprios (momentos principais) 
    e vetores próprios (eixos principais).
    
    Parameters
    ----------
    inertia_matrix : numpy.ndarray
        Matriz de inércia simétrica (2x2 ou 3x3).
    
    Returns
    -------
    tuple
        Um par contendo:
        - principal_moments: numpy.ndarray
            Momentos principais de inércia (valores próprios da matriz).
        - principal_axes: numpy.ndarray
            Eixos principais (vetores próprios da matriz), cada coluna corresponde a um eixo.
    
    Examples
    --------
    &gt;&gt;&gt; I = np.array([[3, 1], [1, 2]])
    &gt;&gt;&gt; moments, axes = calculate_principal_moments(I)
    &#34;&#34;&#34;
    # Verifica se a matriz é simétrica (propriedade importante para matrizes de inércia)
    if not np.allclose(inertia_matrix, inertia_matrix.T):
        raise ValueError(&#34;A matriz de inércia deve ser simétrica&#34;)
    
    # Calcula os valores próprios (momentos principais) e vetores próprios (eixos principais)
    principal_moments, principal_axes = np.linalg.eig(inertia_matrix)
    
    return principal_moments, principal_axes</code></pre>
</details>
<div class="desc"><p>Calcula os momentos principais de inércia e os eixos principais a partir de uma matriz de inércia.</p>
<p>Esta função decompõe a matriz de inércia em seus valores próprios (momentos principais)
e vetores próprios (eixos principais).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inertia_matrix</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Matriz de inércia simétrica (2x2 ou 3x3).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Um par contendo:
- principal_moments: numpy.ndarray
Momentos principais de inércia (valores próprios da matriz).
- principal_axes: numpy.ndarray
Eixos principais (vetores próprios da matriz), cada coluna corresponde a um eixo.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; I = np.array([[3, 1], [1, 2]])
&gt;&gt;&gt; moments, axes = calculate_principal_moments(I)
</code></pre></div>
</dd>
<dt id="mesh3d.compute_inertia_matrix_from_grid"><code class="name flex">
<span>def <span class="ident">compute_inertia_matrix_from_grid</span></span>(<span>weight_matrix)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_inertia_matrix_from_grid(weight_matrix):
    &#34;&#34;&#34;
    Calcula a matriz de inércia e o centro de massa a partir de uma matriz de pesos.
    
    Parâmetros:
    - weight_matrix: Matriz bidimensional onde cada entrada representa o peso de um ponto.

    Retorna:
    - I: Matriz de inércia 2x2
    - center_of_mass: Tupla (x_bar, y_bar) com as coordenadas do centro de massa
    &#34;&#34;&#34;
    weight_matrix = np.array(weight_matrix)  # Garante que os pesos estão como um array NumPy

    # Dimensões da matriz
    nx, ny = weight_matrix.shape

    # Criando listas de coordenadas correspondentes
    x_coords, y_coords = np.meshgrid(np.arange(nx), np.arange(ny), indexing=&#39;ij&#39;)

    # Achando o centro de massa
    total_weight = np.sum(weight_matrix)
    if total_weight == 0:
        x_bar, y_bar = 0, 0  # Or some other appropriate default value
    else:
        x_bar = np.sum(weight_matrix * x_coords) / total_weight
        y_bar = np.sum(weight_matrix * y_coords) / total_weight


    # Construção da matriz de inércia
    I_xx = np.sum(weight_matrix * (y_coords - y_bar) ** 2)
    I_yy = np.sum(weight_matrix * (x_coords - x_bar) ** 2)
    I_xy = -np.sum(weight_matrix * (x_coords - x_bar) * (y_coords - y_bar))

    I = np.array([[I_xx, I_xy],
                  [I_xy, I_yy]])

    return I, (x_bar, y_bar)    </code></pre>
</details>
<div class="desc"><p>Calcula a matriz de inércia e o centro de massa a partir de uma matriz de pesos.</p>
<p>Parâmetros:
- weight_matrix: Matriz bidimensional onde cada entrada representa o peso de um ponto.</p>
<p>Retorna:
- I: Matriz de inércia 2x2
- center_of_mass: Tupla (x_bar, y_bar) com as coordenadas do centro de massa</p></div>
</dd>
<dt id="mesh3d.compute_weight_array"><code class="name flex">
<span>def <span class="ident">compute_weight_array</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_weight_array(mesh):
    &#34;&#34;&#34;
    Calcula o array de pesos para a projeção 2D ao longo da direção Z.
    
    Os pesos são calculados somando os valores das células ao longo do eixo Z.
    
    Parameters
    ----------
    mesh : numpy.ndarray
        Array tridimensional representando a malha 3D.
        
    Returns
    -------
    numpy.ndarray
        Array bidimensional com os pesos calculados, representando
        a projeção da malha 3D no plano XY.
    
    Examples
    --------
    &gt;&gt;&gt; mesh = create_3d_mesh(8, 8, 3)
    &gt;&gt;&gt; weights = compute_weight_array(mesh)
    &gt;&gt;&gt; print(weights.shape)
    (8, 8)
    &#34;&#34;&#34;
    weight_array = np.sum(mesh, axis=2)  # Soma ao longo do eixo Z
    return weight_array</code></pre>
</details>
<div class="desc"><p>Calcula o array de pesos para a projeção 2D ao longo da direção Z.</p>
<p>Os pesos são calculados somando os valores das células ao longo do eixo Z.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array tridimensional representando a malha 3D.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Array bidimensional com os pesos calculados, representando
a projeção da malha 3D no plano XY.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; mesh = create_3d_mesh(8, 8, 3)
&gt;&gt;&gt; weights = compute_weight_array(mesh)
&gt;&gt;&gt; print(weights.shape)
(8, 8)
</code></pre></div>
</dd>
<dt id="mesh3d.create_3d_mesh"><code class="name flex">
<span>def <span class="ident">create_3d_mesh</span></span>(<span>nx=8, ny=8, nz=3, active_intervals=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_3d_mesh(nx=8, ny=8, nz=3, active_intervals=None):
    &#34;&#34;&#34;
    Cria uma malha 3D logicamente retangular, definindo células ativas por intervalos variáveis por linha e camada.
    
    A malha é inicializada com zeros (células inativas) e depois são ativadas células específicas de acordo
    com os intervalos definidos no dicionário `active_intervals`.
    
    Parameters
    ----------
    nx : int, optional
        Número de células na direção X. Valor padrão é 8.
    ny : int, optional
        Número de células na direção Y. Valor padrão é 8.
    nz : int, optional
        Número de células na direção Z. Valor padrão é 3.
    active_intervals : dict, optional
        Dicionário definindo os intervalos de células ativas. A estrutura do dicionário é:
        {k: {i: [(j_start, j_end), ...], ...}, ...} onde:
        - k é o índice da camada (direção Z)
        - i é o índice da linha (direção X)
        - (j_start, j_end) são tuplas definindo o intervalo de colunas ativas (direção Y)
        Se None, utiliza um padrão predefinido.
        
    Returns
    -------
    numpy.ndarray
        Array tridimensional de dimensões (nx, ny, nz) representando a malha 3D,
        onde 1 indica células ativas e 0 indica células inativas.
    
    Examples
    --------
    &gt;&gt;&gt; # Exemplo com configuração padrão
    &gt;&gt;&gt; mesh = create_3d_mesh()
    &gt;&gt;&gt; print(mesh.shape)
    (8, 8, 3)
    
    &gt;&gt;&gt; # Exemplo com intervalos customizados
    &gt;&gt;&gt; custom_intervals = {
    ...     0: {2: [(3, 4)], 3: [(2, 5)]},
    ...     1: {1: [(2, 5)], 2: [(1, 6)]}
    ... }
    &gt;&gt;&gt; mesh = create_3d_mesh(active_intervals=custom_intervals)
    &#34;&#34;&#34;
    # Configuração padrão dos intervalos ativos se não forem fornecidos
    if active_intervals is None:
        active_intervals = {
            0: {2: [(3, 4)], 3: [(2, 5)], 4: [(2, 5)], 5: [(3, 4)]},
            1: {1: [(2, 5)], 2: [(1, 6)], 3: [(1, 6)], 4: [(1, 6)], 5: [(1, 6)], 6: [(2, 5)]},
            2: {0: [(2, 5)], 1: [(1, 6)], 2: [(0, 7)], 3: [(0, 7)], 4: [(0, 7)], 5: [(0, 7)], 6: [(1, 6)], 7: [(2, 5)]}
        }
    
    mesh = np.zeros((nx, ny, nz), dtype=int)  # Inicializa todas as células como vazias
    
    for k, layers in active_intervals.items():
        for i, intervals in layers.items():
            for j_start, j_end in intervals:
                # Verifica se os índices estão dentro dos limites da malha
                if i &lt; nx and k &lt; nz :  #Removed j_end &lt; ny
                    # Ajusta o intervalo final se necessário
                    j_end_adjusted = min(j_end, ny)
                    mesh[i, j_start:j_end_adjusted, k] = 1  # Ativa apenas as células dentro dos intervalos
    
    # for k, layers in active_intervals.items():
    #     for i, intervals in layers.items():
    #         for j_start, j_end in intervals:
    #             # Verifica se os índices estão dentro dos limites da malha
    #             if i &lt; nx and k &lt; nz and j_end &lt; ny:
    #                 # Ajusta o intervalo final se necessário
    #                 j_end_adjusted = min(j_end, ny)
    #                 mesh[i, j_start:j_end_adjusted, k] = 1  # Ativa apenas as células dentro dos intervalos
    
    return mesh</code></pre>
</details>
<div class="desc"><p>Cria uma malha 3D logicamente retangular, definindo células ativas por intervalos variáveis por linha e camada.</p>
<p>A malha é inicializada com zeros (células inativas) e depois são ativadas células específicas de acordo
com os intervalos definidos no dicionário <code>active_intervals</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nx</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Número de células na direção X. Valor padrão é 8.</dd>
<dt><strong><code>ny</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Número de células na direção Y. Valor padrão é 8.</dd>
<dt><strong><code>nz</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Número de células na direção Z. Valor padrão é 3.</dd>
<dt><strong><code>active_intervals</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dicionário definindo os intervalos de células ativas. A estrutura do dicionário é:
{k: {i: [(j_start, j_end), &hellip;], &hellip;}, &hellip;} onde:
- k é o índice da camada (direção Z)
- i é o índice da linha (direção X)
- (j_start, j_end) são tuplas definindo o intervalo de colunas ativas (direção Y)
Se None, utiliza um padrão predefinido.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Array tridimensional de dimensões (nx, ny, nz) representando a malha 3D,
onde 1 indica células ativas e 0 indica células inativas.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Exemplo com configuração padrão
&gt;&gt;&gt; mesh = create_3d_mesh()
&gt;&gt;&gt; print(mesh.shape)
(8, 8, 3)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Exemplo com intervalos customizados
&gt;&gt;&gt; custom_intervals = {
...     0: {2: [(3, 4)], 3: [(2, 5)]},
...     1: {1: [(2, 5)], 2: [(1, 6)]}
... }
&gt;&gt;&gt; mesh = create_3d_mesh(active_intervals=custom_intervals)
</code></pre></div>
</dd>
<dt id="mesh3d.plot_3d_mesh_with_weights"><code class="name flex">
<span>def <span class="ident">plot_3d_mesh_with_weights</span></span>(<span>mesh, show_refinement=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_3d_mesh_with_weights(mesh, show_refinement=False):
    &#34;&#34;&#34;
    Plota a malha 3D mostrando as células ativas com base nos pesos.
    
    As células ativas não refinadas são mostradas com alta transparência,
    enquanto as células refinadas são destacadas com cores mais visíveis.
    Células inativas são quase invisíveis.
    
    Parameters
    ----------
    mesh : numpy.ndarray
        Array tridimensional representando a malha 3D, onde valores positivos
        indicam células ativas.
    show_refinement : bool, optional
        Se True, mostra as células refinadas com cores distintas. Se False,
        mostra apenas células ativas/inativas. Valor padrão é False.
    
    Returns
    -------
    None
        A função cria e exibe um gráfico 3D, mas não retorna nenhum valor.
    &#34;&#34;&#34;
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection=&#39;3d&#39;)
    
    # Define cores para células inativas, ativas não refinadas e refinadas
    inactive_color = (1, 0, 0, 0.05)  # Vermelho quase invisível
    active_color = (0, 0, 1, 0.2)     # Azul com alta transparência
    
    if show_refinement:
        # Normaliza os valores para coloração
        max_value = np.max(mesh)
        norm = Normalize(vmin=1, vmax=max_value)
        cmap = colormaps[&#39;viridis&#39;]  # Use viridis colormap for refinement values
        
        title = &#39;Malha 3D com Células Refinadas&#39;
    else:
        title = &#39;Malha 3D com Células Ativas/Inativas&#39;

    # Dimensões da malha
    nx, ny, nz = mesh.shape

    # Função para criar vértices de um cubo
    def cubo_vertices(x, y, z):
        &#34;&#34;&#34;
        Retorna os vértices de um cubo dadas as coordenadas de um dos seus vértices.
        &#34;&#34;&#34;
        return [
            [x, y, z],
            [x + 1, y, z],
            [x + 1, y + 1, z],
            [x, y + 1, z],
            [x, y, z + 1],
            [x + 1, y, z + 1],
            [x + 1, y + 1, z + 1],
            [x, y + 1, z + 1]
        ]

    # Função para criar faces de um cubo a partir dos vértices
    def cubo_faces(verts):
        &#34;&#34;&#34;
        Retorna as faces de um cubo a partir dos seus vértices.
        &#34;&#34;&#34;
        return [
            # First face: top face
            [verts[0], verts[1], verts[5], verts[4]],
            # Second face: bottom face
            [verts[7], verts[6], verts[2], verts[3]],
            # Third face: front face
            [verts[0], verts[3], verts[7], verts[4]],
            # Fourth face: back face
            [verts[1], verts[2], verts[6], verts[5]],
            # Fifth face: left face
            [verts[0], verts[1], verts[2], verts[3]],
            # Sixth face: right face
            [verts[4], verts[5], verts[6], verts[7]]
        ]

    # Lista para armazenar todas as células, ordenadas pelo valor de refinamento
    all_cells = []
    
    # Percorre todas as células da malha e armazena para ordenação posterior
    for i in range(nx):
        for j in range(ny):
            for k in range(nz):
                cell_value = mesh[i, j, k]
                verts = cubo_vertices(i, j, k)
                faces = cubo_faces(verts)
                
                # Define a cor com base no valor da célula
                if cell_value &lt;= 0:
                    color = inactive_color
                    z_order = -1  # Células inativas têm prioridade mais baixa
                elif cell_value == 1:
                    color = active_color
                    z_order = 0   # Células ativas não refinadas têm prioridade média
                else:
                    if show_refinement:
                        # Usa o colormap para células refinadas com transparência ajustada
                        color_rgba = list(cmap(norm(cell_value)))
                        # Células refinadas têm transparência menor (mais visíveis)
                        color_rgba[3] = 0.8  
                        color = tuple(color_rgba)
                        z_order = cell_value  # Células mais refinadas têm prioridade mais alta
                    else:
                        # No modo não-refinamento, usa a cor azul padrão, mas mais opaca
                        color = (0, 0, 1, 0.6)
                        z_order = 1
                
                all_cells.append((z_order, faces, color))
    
    # Ordena as células pela prioridade de desenho (z-order)
    # Células com valores menores (inativas, depois não refinadas) são desenhadas primeiro
    all_cells.sort(key=lambda x: x[0])
    
    # Adiciona as células ao gráfico na ordem correta
    for _, faces, color in all_cells:
        poly3d = Poly3DCollection(faces, facecolors=color, linewidths=0.1, edgecolors=&#39;k&#39;)
        ax.add_collection3d(poly3d)

    # Configurações do gráfico
    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Y&#39;)
    ax.set_zlabel(&#39;Z&#39;)
    ax.set_xlim(0, nx)
    ax.set_ylim(0, ny)
    ax.set_zlim(0, nz)
    ax.view_init(elev=20, azim=30)  # Ajusta a visualização 3D
    ax.set_title(title)
    
    # Adiciona uma legenda colorida se estiver mostrando refinamento
    if show_refinement:
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax, orientation=&#39;vertical&#39;, 
                           label=&#39;Fator de Refinamento&#39;)</code></pre>
</details>
<div class="desc"><p>Plota a malha 3D mostrando as células ativas com base nos pesos.</p>
<p>As células ativas não refinadas são mostradas com alta transparência,
enquanto as células refinadas são destacadas com cores mais visíveis.
Células inativas são quase invisíveis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array tridimensional representando a malha 3D, onde valores positivos
indicam células ativas.</dd>
<dt><strong><code>show_refinement</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Se True, mostra as células refinadas com cores distintas. Se False,
mostra apenas células ativas/inativas. Valor padrão é False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>A função cria e exibe um gráfico 3D, mas não retorna nenhum valor.</dd>
</dl></div>
</dd>
<dt id="mesh3d.plot_3d_mesh_with_weights_old"><code class="name flex">
<span>def <span class="ident">plot_3d_mesh_with_weights_old</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_3d_mesh_with_weights_old(mesh):
    &#34;&#34;&#34;
    Plota a malha 3D mostrando as células ativas com base nos pesos.
    
    As células ativas são mostradas em azul com transparência, enquanto as células
    inativas são mostradas em vermelho claro com alta transparência.
    
    Parameters
    ----------
    mesh : numpy.ndarray
        Array tridimensional representando a malha 3D, onde valores positivos
        indicam células ativas.
    
    Returns
    -------
    None
        A função cria e exibe um gráfico 3D, mas não retorna nenhum valor.
    
    Notes
    -----
    Esta função usa a biblioteca Matplotlib para criar uma visualização 3D da malha.
    As células são representadas como cubos com cores diferentes dependendo do seu estado.
    &#34;&#34;&#34;
    fig = plt.figure()
    ax = fig.add_subplot(111, projection=&#39;3d&#39;)
    
    # Define cores para células ativas e inativas
    active_color = (0, 0, 1, 0.5)  # Azul com transparência
    inactive_color = (1, 0, 0, 0.01)  # Vermelho claro com transparência

    # Dimensões da malha
    nx, ny, nz = mesh.shape

    # Função para criar vértices de um cubo
    def cubo_vertices(x, y, z):
        &#34;&#34;&#34;
        Retorna os vértices de um cubo dadas as coordenadas de um dos seus vértices.
        
        Parameters
        ----------
        x : int
            Coordenada X do vértice inicial.
        y : int
            Coordenada Y do vértice inicial.
        z : int
            Coordenada Z do vértice inicial.
            
        Returns
        -------
        list
            Lista com as coordenadas dos 8 vértices do cubo.
        &#34;&#34;&#34;
        # Return a list of the coordinates of the vertices of the cube
        return [
            [x, y, z],
            [x + 1, y, z],
            [x + 1, y + 1, z],
            [x, y + 1, z],
            [x, y, z + 1],
            [x + 1, y, z + 1],
            [x + 1, y + 1, z + 1],
            [x, y + 1, z + 1]
        ]

    # Função para criar faces de um cubo a partir dos vértices
    def cubo_faces(verts):
        &#34;&#34;&#34;
        Retorna as faces de um cubo a partir dos seus vértices.
        
        Parameters
        ----------
        verts : list
            Lista com as coordenadas dos 8 vértices do cubo.
            
        Returns
        -------
        list
            Lista com as 6 faces do cubo, onde cada face é uma lista de 4 vértices.
        &#34;&#34;&#34;
        # Return a list of faces, each face is a list of vertices
        return [
            # First face: top face
            [verts[0], verts[1], verts[5], verts[4]],
            # Second face: bottom face
            [verts[7], verts[6], verts[2], verts[3]],
            # Third face: front face
            [verts[0], verts[3], verts[7], verts[4]],
            # Fourth face: back face
            [verts[1], verts[2], verts[6], verts[5]],
            # Fifth face: left face
            [verts[0], verts[1], verts[2], verts[3]],
            # Sixth face: right face
            [verts[4], verts[5], verts[6], verts[7]]
        ]

    # Percorre todas as células da malha
    for i in range(nx):
        for j in range(ny):
            for k in range(nz):
                # Obtém os vértices do cubo na posição (i, j, k)
                verts = cubo_vertices(i, j, k)
                faces = cubo_faces(verts)
                # Define a cor com base no peso
                color = active_color if mesh[i, j, k] &gt; 0 else inactive_color
                # Cria a coleção de polígonos para as faces do cubo
                poly3d = Poly3DCollection(faces, facecolors=color, linewidths=0.1, edgecolors=&#39;k&#39;)
                ax.add_collection3d(poly3d)

    # Configurações do gráfico
    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Y&#39;)
    ax.set_zlabel(&#39;Z&#39;)
    ax.set_xlim(0, nx)
    ax.set_ylim(0, ny)
    ax.set_zlim(0, nz)
    ax.view_init(elev=20, azim=30)  # Ajusta a visualização 3D</code></pre>
</details>
<div class="desc"><p>Plota a malha 3D mostrando as células ativas com base nos pesos.</p>
<p>As células ativas são mostradas em azul com transparência, enquanto as células
inativas são mostradas em vermelho claro com alta transparência.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array tridimensional representando a malha 3D, onde valores positivos
indicam células ativas.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>A função cria e exibe um gráfico 3D, mas não retorna nenhum valor.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Esta função usa a biblioteca Matplotlib para criar uma visualização 3D da malha.
As células são representadas como cubos com cores diferentes dependendo do seu estado.</p></div>
</dd>
<dt id="mesh3d.plot_both_mesh_views"><code class="name flex">
<span>def <span class="ident">plot_both_mesh_views</span></span>(<span>mesh)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_both_mesh_views(mesh):
    &#34;&#34;&#34;
    Cria duas visualizações da malha 3D lado a lado:
    1. Visualização simples (ativa/inativa)
    2. Visualização com células refinadas coloridas
    
    Células não refinadas são quase transparentes para permitir melhor
    visualização das células refinadas no interior da malha.
    
    Parameters
    ----------
    mesh : numpy.ndarray
        Array tridimensional representando a malha 3D.
    
    Returns
    -------
    None
        A função cria e exibe dois gráficos 3D, mas não retorna nenhum valor.
    &#34;&#34;&#34;
    # Configuração do layout
    fig = plt.figure(figsize=(15, 7))
    
    # Primeiro gráfico: visualização simples
    ax1 = fig.add_subplot(121, projection=&#39;3d&#39;)
    plot_mesh_in_axis(ax1, mesh, show_refinement=False)
    ax1.set_title(&#39;Malha 3D com Células Ativas/Inativas&#39;)
    
    # Segundo gráfico: visualização com refinamento
    ax2 = fig.add_subplot(122, projection=&#39;3d&#39;)
    plot_mesh_in_axis(ax2, mesh, show_refinement=True)
    ax2.set_title(&#39;Malha 3D com Células Refinadas&#39;)
    
    plt.tight_layout()</code></pre>
</details>
<div class="desc"><p>Cria duas visualizações da malha 3D lado a lado:
1. Visualização simples (ativa/inativa)
2. Visualização com células refinadas coloridas</p>
<p>Células não refinadas são quase transparentes para permitir melhor
visualização das células refinadas no interior da malha.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array tridimensional representando a malha 3D.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>A função cria e exibe dois gráficos 3D, mas não retorna nenhum valor.</dd>
</dl></div>
</dd>
<dt id="mesh3d.plot_mesh_in_axis"><code class="name flex">
<span>def <span class="ident">plot_mesh_in_axis</span></span>(<span>ax, mesh, show_refinement)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_mesh_in_axis(ax, mesh, show_refinement):
    &#34;&#34;&#34;
    Função auxiliar para plotar uma malha 3D em um eixo específico.
    Células não refinadas são quase transparentes, enquanto células
    refinadas são destacadas.
    
    Parameters
    ----------
    ax : matplotlib.axes.Axes
        O eixo onde a malha será plotada.
    mesh : numpy.ndarray
        Array tridimensional representando a malha 3D.
    show_refinement : bool
        Se True, mostra as células refinadas com cores distintas.
    &#34;&#34;&#34;
    # Define cores para células inativas, ativas não refinadas
    inactive_color = (1, 0, 0, 0.05)  # Vermelho quase invisível
    active_color = (0, 0, 1, 0.2)     # Azul com alta transparência
    
    if show_refinement:
        # Normaliza os valores para coloração
        max_value = np.max(mesh)
        norm = Normalize(vmin=1, vmax=max_value)
        cmap = colormaps[&#39;viridis&#39;]  # Use viridis colormap for refinement values
    
    # Dimensões da malha
    nx, ny, nz = mesh.shape
    
    # Função para criar vértices de um cubo
    def cubo_vertices(x, y, z):
        return [
            [x, y, z],
            [x + 1, y, z],
            [x + 1, y + 1, z],
            [x, y + 1, z],
            [x, y, z + 1],
            [x + 1, y, z + 1],
            [x + 1, y + 1, z + 1],
            [x, y + 1, z + 1]
        ]
    
    # Função para criar faces de um cubo a partir dos vértices
    def cubo_faces(verts):
        return [
            [verts[0], verts[1], verts[5], verts[4]],
            [verts[7], verts[6], verts[2], verts[3]],
            [verts[0], verts[3], verts[7], verts[4]],
            [verts[1], verts[2], verts[6], verts[5]],
            [verts[0], verts[1], verts[2], verts[3]],
            [verts[4], verts[5], verts[6], verts[7]]
        ]
    
    # Lista para armazenar todas as células, ordenadas pelo valor de refinamento
    all_cells = []
    
    # Percorre todas as células da malha e armazena para ordenação posterior
    for i in range(nx):
        for j in range(ny):
            for k in range(nz):
                cell_value = mesh[i, j, k]
                verts = cubo_vertices(i, j, k)
                faces = cubo_faces(verts)
                
                # Define a cor com base no valor da célula
                if cell_value &lt;= 0:
                    color = inactive_color
                    z_order = -1  # Células inativas têm prioridade mais baixa
                elif cell_value == 1:
                    color = active_color
                    z_order = 0   # Células ativas não refinadas têm prioridade média
                else:
                    if show_refinement:
                        # Usa o colormap para células refinadas com transparência ajustada
                        color_rgba = list(cmap(norm(cell_value)))
                        # Células refinadas têm transparência menor (mais visíveis)
                        color_rgba[3] = 0.8  
                        color = tuple(color_rgba)
                        z_order = cell_value  # Células mais refinadas têm prioridade mais alta
                    else:
                        # No modo não-refinamento, usa a cor azul padrão, mas mais opaca
                        color = (0, 0, 1, 0.6)
                        z_order = 1
                
                all_cells.append((z_order, faces, color))
    
    # Ordena as células pela prioridade de desenho (z-order)
    all_cells.sort(key=lambda x: x[0])
    
    # Adiciona as células ao gráfico na ordem correta
    for _, faces, color in all_cells:
        poly3d = Poly3DCollection(faces, facecolors=color, linewidths=0.1, edgecolors=&#39;k&#39;)
        ax.add_collection3d(poly3d)
    
    # Configurações do gráfico
    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Y&#39;)
    ax.set_zlabel(&#39;Z&#39;)
    ax.set_xlim(0, nx)
    ax.set_ylim(0, ny)
    ax.set_zlim(0, nz)
    ax.view_init(elev=20, azim=30)  # Ajusta a visualização 3D
    
    # Adiciona uma legenda colorida se estiver mostrando refinamento
    if show_refinement:
        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        sm.set_array([])
        plt.colorbar(sm, ax=ax, orientation=&#39;vertical&#39;, 
                     label=&#39;Fator de Refinamento&#39;)</code></pre>
</details>
<div class="desc"><p>Função auxiliar para plotar uma malha 3D em um eixo específico.
Células não refinadas são quase transparentes, enquanto células
refinadas são destacadas.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code></dt>
<dd>O eixo onde a malha será plotada.</dd>
<dt><strong><code>mesh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array tridimensional representando a malha 3D.</dd>
<dt><strong><code>show_refinement</code></strong> :&ensp;<code>bool</code></dt>
<dd>Se True, mostra as células refinadas com cores distintas.</dd>
</dl></div>
</dd>
<dt id="mesh3d.plot_weights"><code class="name flex">
<span>def <span class="ident">plot_weights</span></span>(<span>weight_array)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_weights(weight_array):
    &#34;&#34;&#34;
    Plota a matriz de pesos como uma imagem 2D colorida com os valores sobrepostos.
    
    Parameters
    ----------
    weight_array : numpy.ndarray
        Array bidimensional com os pesos calculados.
    
    Returns
    -------
    None
        A função cria e exibe um gráfico 2D, mas não retorna nenhum valor.
    
    Notes
    -----
    Esta função usa a biblioteca Matplotlib para criar uma visualização 2D da matriz de pesos.
    A cor de cada célula é determinada pelo valor do peso, e o valor numérico é mostrado
    dentro de cada célula. A cor do texto é ajustada (preto ou branco) para garantir
    a legibilidade de acordo com o brilho da cor de fundo.
    &#34;&#34;&#34;
    # Função para plotar a matriz de pesos
    fig, ax = plt.subplots()
    cmap = colormaps[&#39;viridis&#39;]  # Escolha o mapa de cores desejado
    norm = Normalize(vmin=weight_array.min(), vmax=weight_array.max())

    # Exibe a matriz de pesos
    cax = ax.imshow(weight_array, cmap=cmap, norm=norm)

    # Adiciona os valores sobre as células
    for (i, j), val in np.ndenumerate(weight_array):
        # Obtém a cor de fundo da célula
        bg_color = cmap(norm(val))
        # Calcula o brilho percebido da cor de fundo
        brightness = 0.299 * bg_color[0] + 0.587 * bg_color[1] + 0.114 * bg_color[2]
        # Define a cor do texto como branco ou preto, dependendo do brilho
        text_color = &#39;white&#39; if brightness &lt; 0.5 else &#39;black&#39;
        ax.text(j, i, f&#39;{val}&#39;, ha=&#39;center&#39;, va=&#39;center&#39;, color=text_color)

    # Adiciona uma barra de cores para referência
    fig.colorbar(cax)

    # Configurações adicionais
    ax.set_title(&#39;Matriz de Pesos&#39;)
    ax.set_xlabel(&#39;Índice da Coluna&#39;)
    ax.set_ylabel(&#39;Índice da Linha&#39;)</code></pre>
</details>
<div class="desc"><p>Plota a matriz de pesos como uma imagem 2D colorida com os valores sobrepostos.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>weight_array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array bidimensional com os pesos calculados.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>A função cria e exibe um gráfico 2D, mas não retorna nenhum valor.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Esta função usa a biblioteca Matplotlib para criar uma visualização 2D da matriz de pesos.
A cor de cada célula é determinada pelo valor do peso, e o valor numérico é mostrado
dentro de cada célula. A cor do texto é ajustada (preto ou branco) para garantir
a legibilidade de acordo com o brilho da cor de fundo.</p></div>
</dd>
<dt id="mesh3d.refine_mesh"><code class="name flex">
<span>def <span class="ident">refine_mesh</span></span>(<span>mesh, refinement_regions)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refine_mesh(mesh, refinement_regions):
    &#34;&#34;&#34;
    Refina a malha tridimensional conforme as regiões definidas por intervalos variáveis.
    
    Para cada camada e linha especificada, refina as células ativas dentro dos
    intervalos definidos, aplicando os fatores de refinamento correspondentes.
    
    Parameters
    ----------
    mesh : numpy.ndarray
        Array tridimensional representando a malha 3D, onde valores positivos
        indicam células ativas.
    refinement_regions : dict
        Dicionário definindo as regiões de refinamento. A estrutura do dicionário é:
        {k: {i: [(j_start, j_end, factor_i, factor_j, factor_k), ...], ...}, ...} onde:
        - k é o índice da camada (direção Z)
        - i é o índice da linha (direção X)
        - (j_start, j_end, factor_i, factor_j, factor_k) são tuplas definindo:
          * j_start, j_end: intervalo de colunas a serem refinadas (direção Y)
          * factor_i, factor_j, factor_k: fatores de refinamento nas direções X, Y e Z
    
    Returns
    -------
    numpy.ndarray
        Malha refinada com a mesma forma do array de entrada.
    
    Examples
    --------
    &gt;&gt;&gt; mesh = create_3d_mesh(8, 8, 3)
    &gt;&gt;&gt; regions = {
    ...     1: {  # camada Z=1
    ...         3: [(2, 4, 2, 2, 1), (5, 6, 3, 1, 1)],  # linha X=3 com dois intervalos
    ...         4: [(3, 5, 2, 3, 1)]  # linha X=4 com um intervalo
    ...     }
    ... }
    &gt;&gt;&gt; refined_mesh = refine_mesh(mesh, regions)
    &#34;&#34;&#34;
    refined_mesh = np.zeros_like(mesh)  # Inicializa com células inativas
    
    # Primeiro, mantém as células ativas originais
    for i in range(mesh.shape[0]):
        for j in range(mesh.shape[1]):
            for k in range(mesh.shape[2]):
                if mesh[i, j, k] &gt; 0:
                    refined_mesh[i, j, k] = 1  # Mantém as células ativas
    
    # Aplica o refinamento por intervalos variáveis
    for k, layers in refinement_regions.items():
        for i, intervals in layers.items():
            for interval in intervals:
                # Verifica se é um intervalo válido com 5 elementos (j_start, j_end, factor_i, factor_j, factor_k)
                if len(interval) == 5:
                    j_start, j_end, factor_i, factor_j, factor_k = interval
                    
                    # Verifica se os índices estão dentro dos limites da malha
                    if (0 &lt;= i &lt; mesh.shape[0] and 
                        0 &lt;= k &lt; mesh.shape[2] and 
                        0 &lt;= j_start &lt;= j_end &lt; mesh.shape[1]):
                        
                        # Aplica o refinamento apenas para células ativas dentro do intervalo
                        for j in range(j_start, j_end + 1):
                            if refined_mesh[i, j, k] &gt; 0:
                                refined_mesh[i, j, k] *= factor_i * factor_j * factor_k
                else:
                    print(f&#34;Aviso: Intervalo inválido ignorado: {interval}. Formato esperado: (j_start, j_end, factor_i, factor_j, factor_k)&#34;)
    
    return refined_mesh</code></pre>
</details>
<div class="desc"><p>Refina a malha tridimensional conforme as regiões definidas por intervalos variáveis.</p>
<p>Para cada camada e linha especificada, refina as células ativas dentro dos
intervalos definidos, aplicando os fatores de refinamento correspondentes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mesh</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Array tridimensional representando a malha 3D, onde valores positivos
indicam células ativas.</dd>
<dt><strong><code>refinement_regions</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dicionário definindo as regiões de refinamento. A estrutura do dicionário é:
{k: {i: [(j_start, j_end, factor_i, factor_j, factor_k), &hellip;], &hellip;}, &hellip;} onde:
- k é o índice da camada (direção Z)
- i é o índice da linha (direção X)
- (j_start, j_end, factor_i, factor_j, factor_k) são tuplas definindo:
* j_start, j_end: intervalo de colunas a serem refinadas (direção Y)
* factor_i, factor_j, factor_k: fatores de refinamento nas direções X, Y e Z</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Malha refinada com a mesma forma do array de entrada.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; mesh = create_3d_mesh(8, 8, 3)
&gt;&gt;&gt; regions = {
...     1: {  # camada Z=1
...         3: [(2, 4, 2, 2, 1), (5, 6, 3, 1, 1)],  # linha X=3 com dois intervalos
...         4: [(3, 5, 2, 3, 1)]  # linha X=4 com um intervalo
...     }
... }
&gt;&gt;&gt; refined_mesh = refine_mesh(mesh, regions)
</code></pre></div>
</dd>
<dt id="mesh3d.visualize_inertia_deformation"><code class="name flex">
<span>def <span class="ident">visualize_inertia_deformation</span></span>(<span>principal_moments, principal_axes, fig_size=(6, 6), title=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize_inertia_deformation(principal_moments, principal_axes, fig_size=(6, 6), title=None):
    &#34;&#34;&#34;
    Visualiza a deformação de uma esfera/círculo unitário com base nos momentos principais de inércia.
    
    Esta função gera um gráfico que mostra como uma esfera/círculo unitário é deformado quando
    transformado pela matriz de inércia, resultando em uma elipse. Também exibe os eixos principais.
    
    Parameters
    ----------
    principal_moments : numpy.ndarray
        Momentos principais de inércia (valores próprios da matriz).
    principal_axes : numpy.ndarray
        Eixos principais (vetores próprios da matriz).
    fig_size : tuple, optional
        Tamanho da figura em polegadas, por padrão (6, 6).
    title : str, optional
        Título do gráfico. Se None, um título padrão é usado.
    
    Returns
    -------
    tuple
        Um par contendo:
        - fig: matplotlib.figure.Figure
            O objeto figura do matplotlib.
        - ax: matplotlib.axes.Axes
            O objeto eixos do matplotlib.
    
    Examples
    --------
    &gt;&gt;&gt; I = np.array([[3, 1], [1, 2]])
    &gt;&gt;&gt; moments, axes = calculate_principal_moments(I)
    &gt;&gt;&gt; fig, ax = visualize_inertia_deformation(moments, axes)
    &gt;&gt;&gt; plt.show()
    &#34;&#34;&#34;
    # Reconstrução da matriz de inércia a partir dos momentos e eixos principais
    inertia_matrix = principal_axes @ np.diag(principal_moments) @ principal_axes.T
    
    # Criação do círculo unitário (pontos uniformemente distribuídos)
    theta = np.linspace(0, 2*np.pi, 100)
    circle = np.array([np.cos(theta), np.sin(theta)])  # Pontos (x, y) no círculo unitário
    
    # Aplicação da matriz de inércia ao círculo para obter a elipse transformada
    ellipse = inertia_matrix @ circle  # Multiplicação matricial
    
    # Criação da figura e eixos
    fig, ax = plt.subplots(figsize=fig_size)
    
    # Plotando o círculo original e a elipse transformada
    ax.plot(circle[0], circle[1], &#39;b--&#39;, label=&#34;Círculo Unitário&#34;)
    ax.plot(ellipse[0], ellipse[1], &#39;r-&#39;, label=&#34;Elipse Transformada&#34;)
    
    # Plotando os vetores próprios (eixos principais da elipse)
    for i in range(len(principal_moments)):
        vec = principal_axes[:, i] * principal_moments[i]  # Escalando os vetores pelos valores próprios
        ax.plot([0, vec[0]], [0, vec[1]], &#39;k&#39;, lw=2, label=f&#34;Eixo {i+1}&#34;)
    
    # Configurações do gráfico
    ax.axhline(0, color=&#39;gray&#39;, linewidth=0.5)  # Linha horizontal no zero
    ax.axvline(0, color=&#39;gray&#39;, linewidth=0.5)  # Linha vertical no zero
    
    # Determina os limites do gráfico com base na elipse e nos vetores
    max_range = max(np.max(np.abs(ellipse)), np.max(np.abs(principal_moments)))
    limit = max_range * 1.2  # Adiciona uma margem de 20%
    ax.set_xlim(-limit, limit)
    ax.set_ylim(-limit, limit)
    
    ax.set_xlabel(&#34;X&#34;)
    ax.set_ylabel(&#34;Y&#34;)
    
    # Define o título do gráfico
    if title is None:
        title = &#34;Transformação do Círculo pela Matriz de Inércia&#34;
    ax.set_title(title)
    
    ax.legend()
    ax.set_aspect(&#39;equal&#39;)  # Mantém a escala igual nos eixos
    
    return fig, ax</code></pre>
</details>
<div class="desc"><p>Visualiza a deformação de uma esfera/círculo unitário com base nos momentos principais de inércia.</p>
<p>Esta função gera um gráfico que mostra como uma esfera/círculo unitário é deformado quando
transformado pela matriz de inércia, resultando em uma elipse. Também exibe os eixos principais.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>principal_moments</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Momentos principais de inércia (valores próprios da matriz).</dd>
<dt><strong><code>principal_axes</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Eixos principais (vetores próprios da matriz).</dd>
<dt><strong><code>fig_size</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>Tamanho da figura em polegadas, por padrão (6, 6).</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Título do gráfico. Se None, um título padrão é usado.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Um par contendo:
- fig: matplotlib.figure.Figure
O objeto figura do matplotlib.
- ax: matplotlib.axes.Axes
O objeto eixos do matplotlib.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; I = np.array([[3, 1], [1, 2]])
&gt;&gt;&gt; moments, axes = calculate_principal_moments(I)
&gt;&gt;&gt; fig, ax = visualize_inertia_deformation(moments, axes)
&gt;&gt;&gt; plt.show()
</code></pre></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mesh3d.calculate_principal_moments" href="#mesh3d.calculate_principal_moments">calculate_principal_moments</a></code></li>
<li><code><a title="mesh3d.compute_inertia_matrix_from_grid" href="#mesh3d.compute_inertia_matrix_from_grid">compute_inertia_matrix_from_grid</a></code></li>
<li><code><a title="mesh3d.compute_weight_array" href="#mesh3d.compute_weight_array">compute_weight_array</a></code></li>
<li><code><a title="mesh3d.create_3d_mesh" href="#mesh3d.create_3d_mesh">create_3d_mesh</a></code></li>
<li><code><a title="mesh3d.plot_3d_mesh_with_weights" href="#mesh3d.plot_3d_mesh_with_weights">plot_3d_mesh_with_weights</a></code></li>
<li><code><a title="mesh3d.plot_3d_mesh_with_weights_old" href="#mesh3d.plot_3d_mesh_with_weights_old">plot_3d_mesh_with_weights_old</a></code></li>
<li><code><a title="mesh3d.plot_both_mesh_views" href="#mesh3d.plot_both_mesh_views">plot_both_mesh_views</a></code></li>
<li><code><a title="mesh3d.plot_mesh_in_axis" href="#mesh3d.plot_mesh_in_axis">plot_mesh_in_axis</a></code></li>
<li><code><a title="mesh3d.plot_weights" href="#mesh3d.plot_weights">plot_weights</a></code></li>
<li><code><a title="mesh3d.refine_mesh" href="#mesh3d.refine_mesh">refine_mesh</a></code></li>
<li><code><a title="mesh3d.visualize_inertia_deformation" href="#mesh3d.visualize_inertia_deformation">visualize_inertia_deformation</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
